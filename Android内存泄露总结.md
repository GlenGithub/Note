# Android内存泄露总结

> 简单的讲就是，该被释放的对象没有被释放，一直被某个或某些实例所持有却不再被使用导致GC不能回收。

### JAVA 内存分配策略

Java程序运行时的内存分配策略有3种：

- **静态分配**
- **栈式分配**
- **堆式分配**

三种存储策略使用的内存空间分别是：

- **静态存储区**
 主要存放`静态数据`、`全局static数据`、`常量`，这块内存在程序编译时就已分配好，并且在程序整个运行期间都存在。
- **栈区**
  当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时，这些局部变量所持有的内存将会自动释放。
- **堆区**
又称动态内存分配，通常指在程序运行时直接`new`出来的内存，这部分内存在不使用时将会由java垃圾回收器来负责回收。

### 栈与堆的区别

在方法体内定义的`局部变量`，一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的，当在一段方法块中定义一个变量时，Java就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给他的内存空间也将被释放掉，该内存空间可以被重新使用。

堆内存用来存放所有由`new`创建的对象 ( 包括该对象其中的所有成员变量 ) 和数组。在堆中分配的内存，将由Java垃圾回收器来自动管理，在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的`引用变量`,我们可以通过这个引用变量来访问堆中的对象和数组。

举个例子:

```
public class Sample {
	
	public void method() {
		int s2 = 1;
		Sample mSample2 = new Sample();
	}
}
```

> Sample 类的局部变量 `s2` 和 引用变量 `mSample2` 都是存在于栈中，但`mSample2`指向的对象是存放于堆上的；

**结论**


局部变量的`基本数据类型`和`引用`存储于栈中，`引用的对象实体`存储于堆中。
—— 因为它们属于方法中的变量，生命周期随方法而结束。

成员变量全部存储于堆中 ( 包括`基本数据类型`，`引用`和`引用的对象实体` ) 
——  因为它们属于类，类对象终究是要被`new`出来使用的。


### Java 是如何管理内存
